     1                                  
     2                                  ;**********************************************
     3                                  ; include 
     4                                  ;**********************************************
     5                                  %include "../include/cdecl.s"
     1                              <1> %macro  cdecl 1-*.nolist
     2                              <1> 
     3                              <1> 	%rep  %0 - 1
     4                              <1> 		push	%{-1:-1}
     5                              <1> 		%rotate -1
     6                              <1> 	%endrep 
     7                              <1> 	%rotate -1
     8                              <1> 
     9                              <1> 		call	%1
    10                              <1> 
    11                              <1> 	%if 1 < %0
    12                              <1> 		add		sp, (__BITS__ >> 3) * (%0 - 1)
    13                              <1> 	%endif
    14                              <1> 
    15                              <1> %endmacro
    16                              <1> 
     6                                  %include "../include/construct.s"
     1                              <1> ;******************************************************
     2                              <1> ; struct drive
     3                              <1> ;******************************************************
     4                              <1> 
     5                              <1> struc drive
     6 00000000 <res 00000002>      <1>     .no   resw 1 ;drive number
     7 00000002 <res 00000002>      <1>     .cyln resw 1 ; cylinder
     8 00000004 <res 00000002>      <1>     .head resw 1 ; head
     9 00000006 <res 00000002>      <1>     .sect resw 1 ; sector
    10                              <1> endstruc
    11                              <1> 
     7                                  %include "../include/define.s"
     1                              <1>   BOOT_LOAD equ 0x7C00                  ; read postion for boot program
     2                              <1> 
     3                              <1>   BOOT_SIZE equ (1024 * 8)              ; boot code size
     4                              <1>   SECT_SIZE equ (512)                   ; sector size
     5                              <1>   BOOT_SECT equ (BOOT_SIZE / SECT_SIZE) ; How sector will read
     8                                        
     9                                  ORG BOOT_LOAD           ; aply road address to asm            ;
    10                                  
    11                                  ;**********************************************
    12                                  ; Entry Point
    13                                  ;**********************************************
    14                                  
    15                                  entry:
    16                                  
    17                                    ;--------------------------------------------------
    18                                    ; BPB (BIOS Parameter Block)
    19                                    ;--------------------------------------------------
    20                                  
    21 00000000 EB58                      jmp ipl               ; jump to ipl
    22 00000002 90<rept>                  times 90 - ($ - $$) db 0x90
    23                                  
    24                                    ;--------------------------------------------------
    25                                    ; IPL(Initial Program Loader)
    26                                    ;--------------------------------------------------
    27                                  
    28                                  ipl:
    29 0000005A FA                          cli                  ; deny interupt
    30                                  
    31 0000005B B80000                      mov ax, 0x0000       ; AX = 0x0000
    32 0000005E 8ED8                        mov ds, ax           ; DS = 0x0000
    33 00000060 8EC0                        mov es, ax           ; ES = 0x0000
    34 00000062 8ED0                        mov ss, ax           ; SS = 0x0000
    35 00000064 BC007C                      mov sp, BOOT_LOAD    ; SP = 0x7C00
    36                                  
    37 00000067 FB                          sti                  ; alow interupt
    38                                  
    39 00000068 8816[BA00]                  mov [BOOT + drive.no], dl ; save bootdrive
    40                                  
    41                                    ;--------------------------------------------------
    42                                    ; output chars
    43                                    ;--------------------------------------------------
    44 0000006C 68[9B00]E8500083C4-         cdecl puts, .s0 
    44 00000074 02                 
    45                                  
    46                                    ;--------------------------------------------------
    47                                    ; read all of sector
    48                                    ;--------------------------------------------------
    49                                      
    50 00000075 BB0F00                        mov bx, BOOT_SECT -1                      ; BX = How many Boot sector left
    51 00000078 B9007E                        mov cx, BOOT_LOAD + SECT_SIZE             ; CX = nexr boot address
    52                                  
    53 0000007B 515368[BA00]E81D01-           cdecl read_chs, BOOT, bx, cx              ; AX = read_chs(BOOT, BX, CX)
    53 00000083 83C406             
    54                                  
    55 00000086 39D8                           cmp ax, bx                                ; if(AX != How many Boot sector left)
    56 00000088 740C                    .10Q:  jz .10E                                   ; {
    57 0000008A 68[A800]E8320083C4-     .10T:  cdecl puts, .e0                            ;   puts(.e0);
    57 00000092 02                 
    58 00000093 E8CB00                         call reboot                               ;   reboot();
    59                                  .10E:                                            ; }
    60                                    
    61                                  
    62                                    ;--------------------------------------------------
    63                                    ; boot processing goes NEXT STAGE!!!!
    64                                    ;--------------------------------------------------
    65 00000096 E96701                        jmp stage_2                                 ; 
    66                                  
    67                                    ;--------------------------------------------------
    68                                    ; End of process
    69                                    ;--------------------------------------------------
    70                                  
    71 00000099 EBFE                      jmp $                 ;while(true)
    72                                  
    73                                    ;--------------------------------------------------
    74                                    ; Data
    75                                    ;--------------------------------------------------
    76 0000009B 426F6F74696E672E2E-     .s0 db "Booting...", 0x0A, 0x0D, 0 
    76 000000A4 2E0A0D00           
    77 000000A8 4572726F723A736563-     .e0 db "Error:sector read", 0
    77 000000B1 746F72207265616400 
    78                                  ;**************************************************
    79                                  ; infomation about boot drive
    80                                  ;**************************************************
    81                                  
    82                                  ALIGN 2, db 0
    83                                  BOOT:                   ; 
    84                                      istruc drive
    85 000000BA 0000                            at drive.no,    dw 0 ; drive number
    86 000000BC 0000                            at drive.cyln,  dw 0 ; C: cylinder
    87 000000BE 0000                            at drive.head,  dw 0 ; H: head
    88 000000C0 0200                            at drive.sect,  dw 2 ; S: Sector
    89                                      iend
    90                                  
    91                                  
    92                                  ;**********************************************
    93                                  ; modules
    94                                  ;**********************************************
    95                                  %include "../modules/real/puts.s"
     1                              <1> puts:
     2                              <1>   ;------------------------------------------------------------
     3                              <1>   ; construct stackframe
     4                              <1>   ;------------------------------------------------------------
     5                              <1> 
     6 000000C2 55                  <1>   push bp
     7 000000C3 89E5                <1>   mov bp, sp
     8                              <1> 
     9                              <1>   ;-----------------------------------------------------------
    10                              <1>   ; save register 
    11                              <1>   ;-----------------------------------------------------------
    12 000000C5 50                  <1>   push ax
    13 000000C6 53                  <1>   push bx
    14 000000C7 56                  <1>   push si
    15                              <1> 
    16                              <1>   ;-----------------------------------------------------------
    17                              <1>   ; get args
    18                              <1>   ;-----------------------------------------------------------
    19 000000C8 8B7604              <1>   mov si, [bp + 4]
    20                              <1> 
    21                              <1>   ;-----------------------------------------------------------
    22                              <1>   ; begining of process
    23                              <1>   ;-----------------------------------------------------------
    24 000000CB B40E                <1>   mov ah, 0x0E              ; teltype char 
    25 000000CD BB0000              <1>   mov bx, 0x0000            ; set o page number char color
    26 000000D0 FC                  <1>   cld                       ; DF = 0 add address
    27                              <1>                             ; do
    28                              <1> .10L:                       ; {
    29 000000D1 AC                  <1>   lodsb                     ; AL = *AL++;
    30                              <1>                             ;
    31 000000D2 3C00                <1>   cmp al, 0                 ; if (0 == AL)
    32 000000D4 7404                <1>   je   .10E                 ;   break;
    33                              <1>                             ; 
    34 000000D6 CD10                <1>   int 0x10                  ; Int10(0x0E, AL); 
    35 000000D8 EBF7                <1>   jmp .10L                  ; while(1);
    36                              <1> .10E:
    37                              <1> 
    38                              <1> 
    39                              <1>   ;-----------------------------------------------------------
    40                              <1>   ; return of register
    41                              <1>   ;-----------------------------------------------------------
    42 000000DA 5E                  <1>   pop si
    43 000000DB 5B                  <1>   pop bx
    44 000000DC 58                  <1>   pop ax
    45                              <1> 
    46                              <1>   ;-----------------------------------------------------------
    47                              <1>   ; deconstruct stackframe
    48                              <1>   ;-----------------------------------------------------------
    49 000000DD 89EC                <1>   mov sp, bp
    50 000000DF 5D                  <1>   pop bp
    51                              <1> 
    52 000000E0 C3                  <1>   ret
    96                                  %include "../modules/real/itoa.s"
     1                              <1> ;**************************************************************
     2                              <1> ; void itoa(num, buff, size, radix, flag)
     3                              <1> ;   return void
     4                              <1> ;   num    original
     5                              <1> ;   buff   disnation buffer
     6                              <1> ;   size   buff size
     7                              <1> ;   radix  2, 8, 10, 16
     8                              <1> ;   flags  def bit flag 
     9                              <1> ;          -------------------------
    10                              <1> ;          B2: filling space 0
    11                              <1> ;          B1: set sign
    12                              <1> ;          B0: vaule hadle signed
    13                              <1> ;**************************************************************
    14                              <1> itoa:
    15                              <1> 
    16                              <1>   ;-----------------------------------------------------------
    17                              <1>   ; construct stackframe
    18                              <1>   ;-----------------------------------------------------------
    19                              <1>                                 ; BP+ 12| flag
    20                              <1>                                 ; BP+ 10| radix
    21                              <1>                                 ; BP+  8| buffer size
    22                              <1>                                 ; BP+  6| buffer address
    23                              <1>                                 ; BP+  4| value
    24                              <1>                                 ; BP+  2| IP(address of return value)
    25                              <1>                                 ; BP+  0| BP(original value)
    26 000000E1 55                  <1>       push bp
    27 000000E2 89E5                <1>       mov  bp, sp
    28                              <1>   ;-----------------------------------------------------------
    29                              <1>   ; save register
    30                              <1>   ;-----------------------------------------------------------
    31 000000E4 50                  <1>       push ax                   
    32 000000E5 53                  <1>       push bx                   
    33 000000E6 51                  <1>       push cx                   
    34 000000E7 52                  <1>       push dx                   ;
    35 000000E8 56                  <1>       push si
    36 000000E9 57                  <1>       push di
    37                              <1> 
    38                              <1>   ;-----------------------------------------------------------
    39                              <1>   ; get arg
    40                              <1>   ;-----------------------------------------------------------
    41 000000EA 8B4604              <1>       mov ax, [bp + 4]          ; val = value; 
    42 000000ED 8B7606              <1>       mov si, [bp + 6]          ; dst = buffer address
    43 000000F0 8B4E08              <1>       mov cx, [bp + 8]          ; size = remaining buffe size
    44                              <1>       
    45 000000F3 89F7                <1>       mov di, si                ; end of buffer
    46 000000F5 01CF                <1>       add di, cx                ; dst = &dst[size - 1];
    47 000000F7 4F                  <1>       dec di                    ; 
    48                              <1> 
    49 000000F8 8B5E0C              <1>       mov bx, word [bp + 12]    ; flags = option;
    50                              <1> 
    51                              <1>   ;-----------------------------------------------------------
    52                              <1>   ; check signed or not
    53                              <1>   ;-----------------------------------------------------------
    54 000000FB F7C30100            <1>       test bx, 0b0001           ; if (flags & 0x01)
    55 000000FF 7408                <1> .10Q: je .10E                   ; {
    56 00000101 83F800              <1>       cmp ax, 0                 ;   if (val < 0)
    57 00000104 7D03                <1> .12Q: jge .12E                  ;   {
    58 00000106 83CB02              <1>       or bx, 0b0010             ;    flags |= 2;
    59                              <1> .12E:                           ;   }
    60                              <1> .10E:                           ; }
    61                              <1> 
    62                              <1>   ;-----------------------------------------------------------
    63                              <1>   ; check sign
    64                              <1>   ;-----------------------------------------------------------
    65 00000109 F7C30200            <1>       test bx, 0b0010           ; if (flags & 0x02)// check sign
    66 0000010D 7410                <1> .20Q: je .20E                   ; {
    67 0000010F 83F800              <1>       cmp ax, 0                 ;   if (val < 0)
    68 00000112 7D07                <1> .22Q: jge .22F                  ;   {
    69 00000114 F7D8                <1>       neg ax                    ;     val *= -1; //reverse sign
    70 00000116 C6042D              <1>       mov [si], byte '-'        ;     *dst = '-';// ouput sign
    71 00000119 EB03                <1>       jmp .22E                  ;   }
    72                              <1> .22F:                           ;   else
    73                              <1>                                 ;   {
    74 0000011B C6042B              <1>       mov [si], byte '+'        ;     *dst = '+';//output sign
    75                              <1> .22E:                           ;   }
    76 0000011E 49                  <1>       dec cx                    ;   size--;      //decriment buff size
    77                              <1> .20E:                           ; }
    78                              <1> 
    79                              <1>   ;-----------------------------------------------------------
    80                              <1>   ; convert to ascii
    81                              <1>   ;-----------------------------------------------------------
    82 0000011F 8B5E0A              <1>       mov bx, [bp + 10]             ; BX = radix;
    83                              <1> .30L:                               ; do
    84                              <1>                                     ; {
    85 00000122 BA0000              <1>       mov dx, 0                     ; 
    86 00000125 F7F3                <1>       div bx                        ; DX = DX:AX % radix;
    87                              <1>                                     ; AX = DX:AX / radix;
    88 00000127 89D6                <1>       mov si, dx                    ; // refer ascii table
    89 00000129 8A94[5101]          <1>       mov dl, byte [.ascii + si]    ; DL = ASCII[DX];
    90                              <1>                                     ;
    91 0000012D 8815                <1>       mov [di], dl                  ; *dst = DL;
    92 0000012F 4F                  <1>       dec di                        ; dst--;
    93                              <1>                                     ;
    94 00000130 83F800              <1>       cmp ax, 0                     ;
    95 00000133 E0ED                <1>       loopnz .30L                   ; } while (AX);
    96                              <1> .30E:
    97                              <1> 
    98                              <1>   ;-----------------------------------------------------------
    99                              <1>   ; filing space
   100                              <1>   ;-----------------------------------------------------------
   101 00000135 83F900              <1>       cmp cx, 0                     ; if (size)
   102 00000138 740D                <1> .40Q: je .40E                       ; {
   103 0000013A B020                <1>       mov al, ' '                   ;   AL = ' '; // filing plank by ' '
   104 0000013C 837E0C04            <1>       cmp [bp + 12], word 0b0100    ;   if (flags & 0x04)
   105 00000140 7502                <1> .42Q  jne .42E                      ;   {
   106 00000142 B030                <1>       mov al, '0'                   ;     AL = '0'; // '0'
   107                              <1> .42E:                               ;   }
   108 00000144 FD                  <1>       std                           ;   // DF = 1(negative direction)
   109 00000145 F3AA                <1>       rep stosb                     ;   while (--CX) *DI-- = ' ';
   110                              <1> .40E:                               ; ]
   111                              <1> 
   112                              <1>   ;-----------------------------------------------------------
   113                              <1>   ; return of register
   114                              <1>   ;-----------------------------------------------------------
   115 00000147 58                  <1>       pop ax
   116 00000148 5B                  <1>       pop bx
   117 00000149 59                  <1>       pop cx
   118 0000014A 5A                  <1>       pop dx
   119 0000014B 5E                  <1>       pop si
   120 0000014C 5F                  <1>       pop di
   121                              <1> 
   122                              <1>   ;-----------------------------------------------------------
   123                              <1>   ; deconstruct stackframe
   124                              <1>   ;-----------------------------------------------------------
   125 0000014D 89EC                <1>       mov sp, bp
   126 0000014F 5D                  <1>       pop bp
   127                              <1> 
   128 00000150 C3                  <1>       ret
   129                              <1> 
   130                              <1>   ;-----------------------------------------------------------
   131                              <1>   ; ASCII TABLE
   132                              <1>   ;-----------------------------------------------------------
   133 00000151 303132333435363738- <1> .ascii db "0123456789ABCDEF"        ; ascii table
   133 0000015A 39414243444546      <1>
    97                                  %include "../modules/real/reboot.s"
     1                              <1> reboot:
     2                              <1>       ;------------------------------------------------------------
     3                              <1>       ; output message
     4                              <1>       ;------------------------------------------------------------
     5 00000161 68[7D01]E85BFF83C4- <1>       cdecl puts, .s0              ; // output reboot message
     5 00000169 02                  <1>
     6                              <1> 
     7                              <1>       ;------------------------------------------------------------
     8                              <1>       ; waiting key input
     9                              <1>       ;------------------------------------------------------------
    10                              <1> .10L:
    11                              <1>       
    12 0000016A B410                <1>       mov ah, 0x10                 ;do
    13 0000016C CD16                <1>       int 0x16                     ;{
    14                              <1>                                    ; // waiting key input
    15 0000016E 3C20                <1>       cmp al, ' '                  ; AL = BIOS(0x16, 0x10);
    16 00000170 75F8                <1>       jne .10L                     ;} while(!ZF);
    17                              <1> 
    18                              <1>       ;------------------------------------------------------------
    19                              <1>       ; output  LFCR
    20                              <1>       ;------------------------------------------------------------
    21 00000172 68[9B01]E84AFF83C4- <1>       cdecl puts, .s1             ;
    21 0000017A 02                  <1>
    22                              <1> 
    23                              <1>       ;------------------------------------------------------------
    24                              <1>       ; reboot
    25                              <1>       ;------------------------------------------------------------
    26 0000017B CD19                <1>       int 0x19
    27                              <1> 
    28                              <1>       ;------------------------------------------------------------
    29                              <1>       ; literal
    30                              <1>       ;------------------------------------------------------------
    31 0000017D 0A0D50757368205350- <1> .s0   db 0x0A, 0x0D, "Push SPACE key to reboot...", 0
    31 00000186 414345206B65792074- <1>
    31 0000018F 6F207265626F6F742E- <1>
    31 00000198 2E2E00              <1>
    32 0000019B 0A0D0A0D00          <1> .s1   db 0x0A, 0x0D, 0x0A, 0x0D, 0
    98                                  %include "../modules/real/read_chs.s"
     1                              <1> ;************************************************
     2                              <1> ; read_chs(drive, sect, dst);
     3                              <1> ;   return how many sector readed
     4                              <1> ;   drive: drive struct address
     5                              <1> ;   sect : How many sector read
     6                              <1> ;   dst  : destnation address
     7                              <1> ;************************************************
     8                              <1> 
     9                              <1> read_chs:
    10                              <1>         ;----------------------------------------
    11                              <1>         ; construct stack frame
    12                              <1>         ;----------------------------------------
    13                              <1> 
    14                              <1> 
    15                              <1> 
    16 000001A0 55                  <1>         push bp
    17 000001A1 89E5                <1>         mov  bp, sp
    18 000001A3 6A03                <1>         push 3
    19 000001A5 6A00                <1>         push 0
    20                              <1> 
    21                              <1>         ;----------------------------------------
    22                              <1>         ; save register
    23                              <1>         ;----------------------------------------
    24                              <1> 
    25 000001A7 53                  <1>         push bx
    26 000001A8 51                  <1>         push cx
    27 000001A9 52                  <1>         push dx
    28 000001AA 06                  <1>         push es
    29 000001AB 56                  <1>         push si
    30                              <1> 
    31                              <1>         ;----------------------------------------
    32                              <1>         ; begining of process
    33                              <1>         ;----------------------------------------
    34                              <1> 
    35 000001AC 8B7604              <1>         mov si, [bp + 4]        ; SI = SRC buffer
    36                              <1> 
    37                              <1> 
    38                              <1>         ;----------------------------------------
    39                              <1>         ; Config CX register
    40                              <1>         ;----------------------------------------
    41                              <1> 
    42 000001AF 8A6C02              <1>         mov ch, [si + drive.cyln + 0] ; CH = cylnder number(low byte)
    43 000001B2 8A4C03              <1>         mov cl, [si + drive.cyln + 1] ; CL = clynder number(high byte)
    44 000001B5 C0E106              <1>         shl cl, 6                     ; CL <<= 6; // shift to highest 2bit
    45 000001B8 0A4C06              <1>         or  cl, [si + drive.sect]      ; CL |= sector number
    46                              <1> 
    47                              <1> 
    48                              <1>         ;----------------------------------------
    49                              <1>         ; read sector
    50                              <1>         ;----------------------------------------
    51                              <1> 
    52 000001BB 8A7404              <1>         mov dh, [si + drive.head]     ; DH = head number;
    53 000001BE 8A14                <1>         mov dl, [si + 0]              ; DL = drive number;
    54 000001C0 B80000              <1>         mov ax, 0x0000                ; AX = 0x0000;
    55 000001C3 8EC0                <1>         mov es, ax                    ; ES = SEGMENT
    56 000001C5 8B5E08              <1>         mov bx, [bp + 8]              ; BX = copy destnation;
    57                              <1> .10L:                                 ;do
    58                              <1>                                       ;{
    59 000001C8 B402                <1>         mov ah, 0x02                  ; AH = read sector;
    60 000001CA 8A4606              <1>         mov al, [bp + 6]              ; AL =  sectors;
    61                              <1>                                       ;
    62 000001CD CD13                <1>         int 0x13                      ; CF = BIOS(0x13, 0x02);
    63 000001CF 7304                <1>         jnc .11E                      ; if(CF)
    64                              <1>                                       ; {
    65 000001D1 B000                <1>         mov al, 0                     ;   AL = 0; 
    66 000001D3 EB0C                <1>         jmp .10E                      ;   break;
    67                              <1> .11E:                                 ; }
    68                              <1>         
    69 000001D5 3C00                <1>         cmp al, 0                     ;   if(readed sector)
    70 000001D7 7508                <1>         jne .10E                      ;     break;
    71                              <1> 
    72 000001D9 B80000              <1>         mov ax, 0                     ;   ret = 0;
    73 000001DC FF4EFE              <1>         dec word[bp - 2]              ; }
    74 000001DF 75E7                <1>         jnz .10L                      ;while(--retry);
    75                              <1> .10E:
    76 000001E1 B400                <1>         mov ah, 0                     ; AH = 0
    77                              <1> 
    78                              <1> 
    79                              <1>         ;----------------------------------------
    80                              <1>         ; return register 
    81                              <1>         ;----------------------------------------
    82                              <1> 
    83 000001E3 5E                  <1>         pop si
    84 000001E4 07                  <1>         pop es
    85 000001E5 5A                  <1>         pop dx
    86 000001E6 59                  <1>         pop cx
    87 000001E7 5B                  <1>         pop bx
    88                              <1> 
    89                              <1>         ;----------------------------------------
    90                              <1>         ; deconstruct stack
    91                              <1>         ;----------------------------------------
    92                              <1> 
    93 000001E8 89EC                <1>         mov sp , bp
    94 000001EA 5D                  <1>         pop bp
    95                              <1> 
    96 000001EB C3                  <1>         ret
    97                              <1> 
    98                              <1>         
    99                                    
   100                                  ;**********************************************
   101                                  ; Boot Flag(End of Head 512 bytes)
   102                                  ;**********************************************
   103 000001EC 00<rept>                    times 510 - ($ - $$) db 0x00
   104 000001FE 55AA                        db 0x55, 0xAA
   105                                  
   106                                  ;**********************************************
   107                                  ; boot process 2nd stage
   108                                  ;**********************************************
   109                                  stage_2:
   110                                  
   111                                    ;--------------------------------------------------
   112                                    ; output literal
   113                                    ;--------------------------------------------------
   114 00000200 68[0B02]E8BCFE83C4-         cdecl puts, .s0
   114 00000208 02                 
   115                                  
   116                                  
   117                                    ;--------------------------------------------------
   118                                    ; end of prossecing
   119                                    ;--------------------------------------------------
   120 00000209 EBFE                        jmp $
   121                                  
   122                                    ;--------------------------------------------------
   123                                    ; data
   124                                    ;--------------------------------------------------
   125 0000020B 326E64207374616765-     .s0 db "2nd stage...", 0x0A, 0x0D, 0
   125 00000214 2E2E2E0A0D00       
   126                                  
   127                                  ;**********************************************
   128                                  ; Padding
   129                                  ;**********************************************
   130 0000021A 00<rept>                    times BOOT_SIZE - ($ - $$) db 0   
